//===-- HeteroplusClean.cpp - Cleaning pass for iHRC code   --------------===//
//
// Copyright (c) 2013 Intel Corporation. All rights reserved.
//                     The iHRC Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE-iHRC.TXT for details.
//
//===----------------------------------------------------------------------===
#include "llvm/Transforms/iHRC/HeteroplusClean.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Operator.h"
using namespace llvm;

void HeteroplusClean::correct_store_alignment(Module &M) {

	for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I){
		vector<Function *>::iterator it = find(trans_hetero_function_set.begin(), trans_hetero_function_set.end(), I);
		if (it != trans_hetero_function_set.end()){
			//		DEBUG(dbgs()<<"Ins:"<<I->getName()<<"\n");
			for (Function::iterator BBI = I->begin(), BBE = I->end(); BBI != BBE; ++BBI) {
				for (BasicBlock::iterator INSNI = BBI->begin(), INSNE = BBI->end(); INSNI != INSNE; ++INSNI) {
					//DEBUG(dbgs()<<"Ins:"<<*INSNI<<"\n");

					if(BinaryOperator *bo = dyn_cast<BinaryOperator>(INSNI)){
						if(bo->isLogicalShift()){
							if(isa<OverflowingBinaryOperator>(INSNI)){
								bo->setHasNoSignedWrap(false);//remove the nsw flag
							}
						}
					}
					if(StoreInst *si = dyn_cast<StoreInst>(INSNI)){
						//DEBUG(dbgs()<<"Store Ins:"<<si->getAlignment()<<"\n");
						//convert store align1 to store align 4
						if(si->getAlignment()==1)si->setAlignment(4);
					}

				}
			}
		}
	}
}

void HeteroplusClean::delete_globals(Module &M) {

	vector<Function *> toDelete;
	vector<GlobalVariable *> toDeleteGlobal; 
	map<Function *, unsigned> repeatNo;
	/*
	1) Delete all the global with undefined address space
	2) Delete all globals which do not use the hetero function
	*/

	for(int i=0;i<10;i++){//repeating it 4 times to remove unused globals generated by removing other globals  
		for (Module::global_iterator I = M.global_begin(), E = M.global_end(); I != E; ++I){
			//DEBUG(dbgs()<<"\nGlobal Ins:"<<I->getName()<<" ");
			if((I->getName().compare(GET_GLOBAL_ID_NAME)!= 0) &&(I->getNumUses()==0&&I->getName()!="hetero.annot.string")/*||I->getName().substr(0,2)=="_Z"*/){
				//DEBUG(dbgs()<<"\nDeleted function(_Z) Global:"<<I->getName()<<"\n");
				toDeleteGlobal.push_back(I);
			}
			else if(I->hasUnnamedAddr()){
				//DEBUG(dbgs()<<"\nDeleted Unnamed Addr Globals:"<<I->getName()<<"\n");
				I->replaceAllUsesWith(UndefValue::get(I->getType()));
				toDeleteGlobal.push_back(I);		
			}
			else{
				/*	for (Value::use_iterator i = I->use_begin(), e = I->use_end(); i!= e; ++i)
				{
				Value *v=cast<Value>(*i);
				User *u=cast<User>(v);
				DEBUG(dbgs()<<"Use "<<*v<<" ;"<< v->getNumUses()<<";"<<*(u->getOperand(0))<<";");
				}*/
				//	DEBUG(dbgs()<<*I<<"\nNum Uses:"<<I->getNumUses()<<"\n");

			}
		}
		while(!toDeleteGlobal.empty()) {
			GlobalVariable *g = toDeleteGlobal.back();
			toDeleteGlobal.pop_back();
			//DEBUG(dbgs()<<"Delete Globals==>" << g->getName()<<"\n");
			g->eraseFromParent();
		}
	}
}

/* Delete Any function aliasing -- Does this assumption break ever */
void HeteroplusClean::delete_func_aliases(Module &M) {

	vector<GlobalAlias *> toDeleteAlias;

	for (Module::alias_iterator I = M.alias_begin(), E = M.alias_end(); I != E; ++I){
		GlobalAlias *ga;
		if (ga = dyn_cast<GlobalAlias>(I)) {
			ga->replaceAllUsesWith(UndefValue::get(ga->getType()));
			toDeleteAlias.push_back(ga);
		}
	}
	while(!toDeleteAlias.empty()) {
		GlobalAlias *g = toDeleteAlias.back();
		toDeleteAlias.pop_back();
		int num_use=0;
		if (g->getNumUses()==0) { 
			//errs() << "\nDelete";
			//DEBUG(dbgs()<<"Delete Alias -->"<<g->getName()<<"\n");
			g->eraseFromParent();
		}
	}
}


/* Delete non hetero function declarations/definitions */
void HeteroplusClean::delete_non_hetero_funcs(Module &M) {

	vector<Function *> toDelete;
	//map<Function *, unsigned> repeatNo;

	for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I){
		//	DEBUG(dbgs()<<"Ins:"<<I->getName()<<"\n");
		vector<Function *>::iterator it = find(trans_hetero_function_set.begin(), trans_hetero_function_set.end(), I);
		Function *f;
		if ((I->getName().compare(GET_GLOBAL_ID_NAME)!= 0) && 
			(!isBuiltinFunction(I)) && 
			(it == trans_hetero_function_set.end()) && (f = dyn_cast<Function>(I))){	
				//DEBUG(dbgs()<<"Func to delete:"<<I->getName()<<"\n");
				f->replaceAllUsesWith(UndefValue::get(f->getType()));
				toDelete.push_back(f);
				//repeatNo.insert(make_pair(I, 0));
		}
		else{
			//DEBUG(dbgs()<<"Cannot Func to delete:"<<I->getName()<<"\n");
		}
	}
	// Can have problems for recursive functions
	// TODO -- check LLVM if it has a clean way of deleting function
	// Quick fix: if a function is three times in the queue then let it be
	while(!toDelete.empty()) {
		//vector<Function *>::iterator it=toDelete.begin();
		Function *f = toDelete.back();
		toDelete.pop_back();
		//errs() << "\n ToDelete Function=" << f->getNameStr();
		//	DEBUG(dbgs()<<"Func to delete:"<<f->getName()<<"\n");
		int num_use=0;

		if (f->getNumUses()==0) { 
			//errs() << "\nDelete";
			//DEBUG(dbgs()<<"Delete Func-->"<<f->getName()<<"\n");
			f->eraseFromParent();
		}
		else{
			//DEBUG(dbgs()<<"F has uses so could not be deleted:"<<f->getName()<<"\n");			
		}
		/*
		else{
		std::map<Function *, unsigned>::iterator iter = repeatNo.find(f);
		unsigned repeat = (unsigned)iter->second;
		if (repeat <= 10) {
		toDelete.insert(toDelete.begin(), f);
		repeatNo.erase(iter);
		repeatNo.insert(make_pair(f, repeat+1));
		}
		}*/
	}

}

bool HeteroplusClean::runOnModule(Module &M) {

	bool localChange = true;

	DEBUG(dbgs() << " Hetero Clean\n");

#if 0
#ifdef OLD_ANNOT
	GlobalVariable *annot = M.getGlobalVariable("llvm.global.annotations");
#else
	GlobalVariable *annot = M.getGlobalVariable("opencl_metadata");
#endif
	DEBUG(dbgs() << "\n Annotations :\n"<<*annot<<"\n\n");

	if (annot != NULL) {
		ConstantArray *Array = dyn_cast<ConstantArray>(annot->getInitializer());
		for (unsigned i = 0, e = Array->getType()->getNumElements(); i != e; ++i) {
			ConstantStruct *element = cast<ConstantStruct>(Array->getOperand(i));
			Function *hetero_f;
			if (hetero_f = dyn_cast<Function>(element->getOperand(0)->stripPointerCasts())) {
				DEBUG(dbgs() << " Hetro_func_name: "<<hetero_f->getName()<<"\n\n");
				hetero_function_set.insert(hetero_f);
			}
		}
	}
#else
	GlobalVariable *annot = M.getGlobalVariable("hetero.annot.string");
	//annot->dump();
	if (annot != NULL) {
		ConstantDataArray *Array = dyn_cast<ConstantDataArray>(annot->getInitializer());
		//Array->dump();
		istringstream str(Array->getAsString());
		vector<string> hetero_f_s;
		copy(istream_iterator<string>(str),
			istream_iterator<string>(),
			back_inserter<vector<string> >(hetero_f_s));
		for (vector<string>::iterator it = hetero_f_s.begin(), ie = hetero_f_s.end(); it != ie; it++) {
			Function *hetero_f = M.getFunction(*it);
			if (hetero_f != NULL) {
				//DEBUG(dbgs()<<"Hetro_funcs:"<<hetero_f->getName()<<"\n");
				hetero_function_set.insert(hetero_f);
				trans_hetero_function_set.push_back(hetero_f);
			}
		}
	}
	unsigned int num_func = trans_hetero_function_set.size();
	for (unsigned int i = 0; i < num_func; i++) {
		Function *F = (Function *)trans_hetero_function_set.at(i);
		for (Function::iterator BB = F->begin(), EE = F->end(); BB != EE; ++BB) {
			for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) {
				Instruction *Call;
				if ((Call = dyn_cast<CallInst>(I)) || (Call = dyn_cast<InvokeInst>(I))) {
					CallSite CI(Call);
					if (Function *F = CI.getCalledFunction()) {
						vector<Function *>::iterator iter1 = std::find(trans_hetero_function_set.begin(), trans_hetero_function_set.end(), F);
						if (iter1 == trans_hetero_function_set.end()) {
							trans_hetero_function_set.push_back(F);
							num_func++;
						}
					}
				}
			}
		}
	}
#endif
	delete_func_aliases(M);
	delete_non_hetero_funcs(M);
	delete_globals(M);
	//correct_store_alignment(M);
	return localChange;
}
