//===-- HeteroCPUTransform.h - API for CPU related code generation  ------===//
//
// Copyright (c) 2013 Intel Corporation. All rights reserved.
//                     The iHRC Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE-iHRC.TXT for details.
//
//===----------------------------------------------------------------------===
#ifndef HETERO_CPU_TRANSFORM_H
#define HETERO_CPU_TRANSFORM_H

#include "llvm/Transforms/iHRC/Hetero.h"
#include "llvm/Transforms/iHRC/HeteroRuntime.h"
#include "llvm/Analysis/LoopInfo.h"
#include <math.h>


namespace {
	/// Hetero CPU Transformation Pass
	struct HeteroCPUTransform : public ModulePass, Hetero, HeteroRuntime {

		static char ID; 
		HeteroCPUTransform() : ModulePass(ID) {}
		void getAnalysisUsage(AnalysisUsage &AU) const {
			//AU.addRequiredTransitive<LoopInfo>();
			AU.addRequired<LoopInfo>();
		}
		bool runOnModule(Module &M);

	private:

		/* file name that containg ghal string */
		static string GHAL_FILE_NAME;

		/* file name that containg opencl string */
		static string CPU_OPENCL_FILE_NAME;

		/* file name that containg opencl string */
		static string GPU_OPENCL_FILE_NAME;


		/* maps from call site to function */
		multimap<Function *, Instruction *> insn2FuncMap;

#ifdef HETERO_GCD_H
		multimap<Function *, Instruction *> insn2BlockMap;
#endif		

		/* kernel function to gpu_join function map */
		map<Function *, Function *> kernel2gpujoinMap;

		/* kernel function to cpu_join function map */
		map<Function *, Function *> kernel2cpujoinMap;

		/* kernel function to cpu_join function map */
		map<Function *, int> kernel2sizeMap;

		/* kernel function to cpu_join function map */
		map<Instruction *, int> insn2schedulerhintMap;

		/* kernel to number of invocations*/
		map<Function *, int> kernel2numinvokeMap;

		/* Type of an integer as specified by the LLVM IR already -- could be uint_64 or uint_32 */
		/*const*/ Type *intArgTy;

		/* Type of the context variable */
		/*const*/ Type *contextPtrTy;
		/*const*/ Type *gContextPtrTy;

		/* Type of the Function Pointer passed in the argument */
		/*const*/ Type *funcPtrTy;

		/* Type of hetero_f function */
		/*const*/ Type *funcApplyFPtrTy;

#ifdef HETERO_GCD_H
		/* Type of hetero function */
		const Type *funcApplyPtrTy;
#endif


		/* GlobalVariable containing the ghal3d ir for CPU transformation */
		GlobalVariable *programIr_ghal;

		/* GlobalVariable containing opencl for CPU transformation */
		GlobalVariable *programIr_cl;

		/* GlobalVariable containing the program, gpu_program_t  */
		GlobalVariable *program;

		/* gpu_program_t  for CPU Transformation */
		/* typedef struct gpu_program_s { 
		* const char* const ir;  // ghal code generated by static compiler 
		* size_t irSize; // size of ir. can be 0 if ir null-terminated 
		* void* volatile binary; // Gen program binary generated by JIT compiler 
		* } gpu_program_t;
		*/
		/*const*/ Type *gpuProgTy;


		/* gpu_function_t for CPU Transformation */
		/* typedef struct gpu_function_s { 
		* gpu_program_t *const program; 
		* const char* const name; // function name to lookup 
		* void* volatile binary;  // Gen function binary generated by JIT compiler 
		* } gpu_function_t; */
		/*const*/ Type *gpuFuncTy;

#ifdef HETERO_GCD_H
		/* Type of heteroQueue extracted from the IR */
		const Type *heteroQueuePtrTy;
		Function *Block_copy_func;
		Function *Block_release_func;
#endif

		/* function prototype */
		Function *dispatch_apply_hetero_f, *join_dispatch_apply_hetero_f;


		/* Set of initial hetero functions */
		set<Function *> entry_hetero_function_set;

		/* Set of final hetero functions after constraints are checked*/
		set<Function *> hetero_function_set;

		/* Generate globals for programIr, program */
		void gen_init_globals(Module &, string, string);

		/* per function gpu_code generation, modification of call sites */
		void gen_globals_transform_per_f (Function *);

		/* Read ghal text or binary */
		string read_text_file(string);

		/* handle calls to hetero functions */
		void handleCall(Function *, Value *);

		/* rewrite call instruction */
		void rewrite_call(CallSite &, Function *, Function *, Value *, bool);
#if 0
#ifdef HETERO_GCD_ALLOC_TO_MALLOC
		/* rewrite alloca instruction to malloc for blocks and block variables */
		void rewrite_alloca(CallSite &);
#endif
#endif

		/* extract typing and other useful information from call sites */
		void extract_type_info(Module &);

		/* Extract join information for reduction code */
		void extract_join_info(Module &);

		/* scheduling related info*/
		const LoopInfo *LI;
		void compute_ratios_for_scheduling(Function *);
		float mem_ratio, control_ratio;

	};
}
string HeteroCPUTransform::GHAL_FILE_NAME="kernel.l.s";
string HeteroCPUTransform::GPU_OPENCL_FILE_NAME="kernel.gpu.cl";
string HeteroCPUTransform::CPU_OPENCL_FILE_NAME="kernel.cpu.cl";


char HeteroCPUTransform::ID = 0;
ModulePass *llvm::createHeteroCPUTransformPass() { return new HeteroCPUTransform(); }
//static RegisterPass<HeteroCPUTransform> X("heterocpu", "Embed OpenCL code in IA code", false, false);

#endif
